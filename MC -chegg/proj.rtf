{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sa240\partightenfactor0

\f0\fs24 \cf0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Added enemy\
\
// class for the satellite and bomber (or other possibble future enemies)\uc0\u8232 class Added_enemy\{\u8232 Particle bomb;\u8232 int bomb_count;\u8232 PVector enemy;\u8232 float drop_location;\u8232 boolean is_alive;\u8232 boolean is_shot;\u8232 int r;\u8232 Added_enemy(float x, float y,int r, float drop)\{\u8232 enemy=new PVector(x,y);\u8232 bomb_count=(int)random(1,5);\u8232 is_alive=true;\u8232 this.r=r;\u8232 drop_location=drop;\u8232 is_shot=false;\u8232 \}\u8232 \u8232 ///checking if the enemy has reached the location its suppposed to drop its payload at\u8232 boolean check_drop()\{\u8232 if((int)enemy.x<=(int)drop_location && bomb_count>0 && is_alive==true)\{\u8232 drop_location=(float)random(enemy.x/2,enemy.x);\u8232 return true;\u8232 \}\u8232 else\u8232 return false; \u8232 \}\u8232 \u8232 //dropping the payload if the location has been reached\u8232 boolean drop_bomb(float velx, float vely)\{\u8232 if(check_drop())\{\u8232 bomb=new Particle(enemy.x,enemy.y,velx,vely,1);\u8232 bomb_count--;\u8232 return true;\u8232 \}\u8232 return false;\u8232 \}\u8232 \u8232 //updating the enemy location to make it move each time its called\u8232 void move(int w, float c)\{\u8232 if(is_alive==true)\u8232 enemy.x-=(float)(2*(float)(w+c)/8);\u8232 if((enemy.x+r)<0)\u8232 is_alive=false;\u8232 \}\u8232 \u8232 //checking if the enemy is colliding with anything (a missile or particle explosion)\u8232 boolean check_collision(float cx, float cy, float cr)\{\u8232 PVector explosion=new PVector(cx,cy);\u8232 if(explosion.dist(enemy)<=((cr/2)+(r/2)))\{\u8232 is_alive=false;\u8232 is_shot=true;\u8232 \}\u8232 return is_alive;\u8232 \}\u8232 \u8232 //drawing the enemy as a circle to keep collision detections simple\u8232 void draw_enemy()\{\u8232 if(is_alive)\{\u8232 fill(84,35,35);\u8232 circle(enemy.x,enemy.y,r);\u8232 \}\u8232 \}\u8232 \}\
\
\
City\
//simple class to store the city coordinates and state(dead or alive)\
class City\{\uc0\u8232 float x1,y1,x2,y2;\u8232 City(float x1, float y1, float x2, float y2)\{\u8232 this.x1=x1;\u8232 this.x2=x2;\u8232 this.y1=y1;\u8232 this.y2=y2;\u8232 \}\u8232 \u8232 boolean isAlive(float a, float b)\{\u8232 if(a<x2 && a>x1 && b<y2 && b>y1)\{\u8232 return false;\u8232 \}\u8232 return true;\u8232 \}\u8232 \}\
\
Level setup\
PVector gravity;\
class Level_Setup\{\uc0\u8232 int wave;\u8232 int noParticles;\u8232 Particle []p;\u8232 int Width;\u8232 int Height;\u8232 PVector gravity;\u8232 Level_Setup(int w, int x, int y)\{\u8232 wave=w;\u8232 Width=x;\u8232 Height=y;\u8232 noParticles=30+(wave*10);\u8232 p=new Particle[noParticles];\u8232 for(int i=0; i<noParticles;i++)\{\u8232 \u8232 PVector position = p[i].position ;\u8232 gravity = new PVector(position.x,position.y+(9.8*y/18000));\u8232 p[i].integrate(gravity);\u8232 fill(0);\u8232 rect(position.x,position.y,2,2);\u8232 \}\u8232 \}\u8232 \u8232 \}\
\
Missile command\
int wave;\uc0\u8232 Particle p[];\u8232 PVector g;\u8232 float scrHeight;\u8232 int counter, rcounter;\u8232 City cities[];\u8232 float distance;\u8232 float altitude;\u8232 float velx;\u8232 int numb;\u8232 int c;\u8232 boolean city_dead[];\u8232 boolean particle_dead[];\u8232 int score;\u8232 int particle_count;\u8232 Silo s[];\u8232 boolean silo_dead[];\u8232 Particle missiles[];\u8232 int active_missile_counter;\u8232 int detonation_counter[];\u8232 int detonation_counter_temp[];\u8232 int detonation_updater[];\u8232 int explosion_counter[];\u8232 int explosion_counter_temp[];\u8232 int explosion_updater[];\u8232 int dead_missiles;\u8232 boolean start;\u8232 boolean reset;\u8232 int extra_particles;\u8232 int splitting_particles;\u8232 int[] child_particles;\u8232 boolean[] is_splitable;\u8232 boolean is_killable[];\u8232 int immortality_timer[];\u8232 boolean explosion_flag[];\u8232 Added_enemy bomber;\u8232 Added_enemy satellite;\u8232 int enemy_counter;\u8232 boolean bomber_is_alive;\u8232 boolean satellite_is_alive;\u8232 int smart_bomb;\u8232 boolean smart_bomb_activated;\u8232 float smart_bomber_originalvelx,smart_bomber_originalvely;\u8232 float smart_timer;\u8232 boolean frame;\u8232 int score_reduction;\
void setup()\{\uc0\u8232 // frameRate(30);\u8232 size(800,600);\u8232 noCursor();\u8232 reset=false;\
//calling the start function to setup the global variables to their default value\uc0\u8232 start();\u8232 \}\u8232 // setting the global variables that are not reset every frame to their default value\u8232 void start()\{\u8232 score_reduction=0;\u8232 enemy_counter=0;\u8232 bomber_is_alive=false;\u8232 satellite_is_alive=false;\u8232 smart_timer=1;\u8232 start=reset;\u8232 score=0;\u8232 c=0;\u8232 distance=width/11f;\u8232 altitude=height;\u8232 wave=0;\u8232 extra_particles=0;\u8232 add_particles();\u8232 cities=new City[6];\u8232 city_dead= new boolean[cities.length];\u8232 for(int i=0;i<city_dead.length;i++)\{\u8232 city_dead[i]=false;\u8232 \}\u8232 s=new Silo[3];\u8232 silo_dead=new boolean[3];\u8232 missiles=new Particle[31];\u8232 active_missile_counter=0;\u8232 scrHeight=(float)height/18000000f;\u8232 g=new PVector(0 ,9.8*scrHeight);\u8232 detonation_counter= new int[30];\u8232 detonation_updater= new int[30];\u8232 detonation_counter_temp= new int[30];\u8232 for(int i=0;i<30;i++)\{\u8232 detonation_counter[i]=1;\u8232 detonation_counter_temp[i]=1;\u8232 detonation_updater[i]=1;\}\u8232 add_silos();\u8232 dead_missiles=0;\u8232 \}\
\uc0\u8232 //setting up and drawing each frame\u8232 void draw()\{\u8232 frame=true;\u8232 \u8232 //checking if the game has crossed the start screen\u8232 if(start==true)\{\u8232 //resetting the background every 3 frames to give all moving obects a sorf of motion blur (tail)\u8232 if(c==3)\{\u8232 background(130,205,255);\u8232 c=0;\}\u8232 c++;\u8232 \u8232 textAlign(LEFT);\u8232 fill(0);\u8232 text("Score: "+(score + score_reduction),10,10);\u8232 fill(0);\u8232 text("Wave: "+wave,(width/2)-20,10);\u8232 for(int i=0;i<particle_dead.length;i++)\u8232 if(particle_dead[i]==false)\u8232 particle_count++;\u8232 text("Particles left: "+ particle_count,width-100,10);\u8232 crosshair();\u8232 \u8232 //checking each particle and handling the various flags to make the particles move if they are alive\u8232 for(int i=0;i<p.length;i++)\{\u8232 remove_particles();\u8232 explosion_flag[i]=false;\u8232 PVector position = p[i].position;\u8232 if(particle_dead[i]==false)\{\u8232 p[i].integrate(g);\u8232 fill(2) ;\u8232 rect(position.x, position.y, 2, 2);\u8232 \}\u8232 \u8232 //drawing cities and silos every frame for each particle detect collision with each\u8232 add_cities(position.x,position.y);\u8232 draw_silos(position.x,position.y);\u8232 \}\u8232 //adding bomber and satellite once every wave\u8232 if(wave>1 && enemy_counter==0)\{\u8232 add_bomber();\u8232 add_satellite();\u8232 enemy_counter++;\u8232 \}\u8232 \u8232 if(wave>1)\{\u8232 handle_bomber();\u8232 handle_satellite();\u8232 \}\u8232 check_wave();\u8232 particle_count=0;\u8232 shoot_missile();\u8232 \}\u8232 \u8232 //displaying the start screen and waiting for the input\u8232 if(start==false)\{\u8232 background(130,205,255);\u8232 crosshair();\u8232 textSize(43);\u8232 textAlign(CENTER);\u8232 fill(38,81,125);\u8232 text("Missile Command",width/2,(height/2)-10);\u8232 textSize(12);\u8232 text("Press Spacebar to Continue!",width/2,(height/2)+10);\u8232 \u8232 if(keyPressed==true && key== ' ')\u8232 start=true;\u8232 \}\u8232 \}\
//initializing and drawing the bomber object and initializing its flag\uc0\u8232 void add_bomber()\{\u8232 bomber=new Added_enemy((float)random(width+50,width+250+(200*wave)),(float)height/2,40, (float)random(width/2,width));\u8232 bomber.draw_enemy();\u8232 bomber_is_alive=bomber.is_alive;\u8232 \}\
//moving the bomber every frame, checking if it reached the drop location\uc0\u8232 //dropping a particle if it reached the drop location\u8232 void handle_bomber()\{\u8232 bomber.move(wave,0);\u8232 bomber.draw_enemy();\u8232 float velx;\u8232 float vely;\u8232 \u8232 //choosing a random target for the particle amongst the 6 cities\u8232 \u8232 int target=(int)random(0,5);\u8232 \u8232 //setting the particle's initial velocity's x coordinate as per the assigned target\u8232 \u8232 switch(target)\{\u8232 case 0:velx=(2*distance+distance/192f);break;\u8232 case 1:velx=(3.1*distance+distance/192f);break;\u8232 case 2:velx=(4.2*distance+distance/192f);break;\u8232 case 3:velx=(6.3*distance+distance/192f);break;\u8232 case 4:velx=(7.4*distance+distance/192f);break;\u8232 case 5:velx=(8.5*distance+distance/192f);break; \u8232 default: velx=0;\u8232 \}\u8232 \u8232 //dampning velocity x coordinate to fit the screen size constraints\u8232 velx=(velx+((distance/4f)-(distance/96f)-bomber.enemy.x))/(280+(abs(bomber.enemy.y)/30));\u8232 \u8232 //setting the particle's initial velocity's y coordinate as per the screen size constraints \u8232 vely=2+(float)wave/32;\u8232 if(bomber.drop_bomb(velx,vely))\{\u8232 int original_length=p.length;\u8232 \u8232 //temporary variables to store the original values of the particle array and the various arrays that work with the particle array\u8232 \u8232 Particle temp[]=p;\u8232 boolean tparticle_dead[]=particle_dead, tis_splitable[]=is_splitable, tis_killable[]=is_killable,texplosion_flag[]=explosion_flag;\u8232 int texplosion_counter[]=explosion_counter, texplosion_counter_temp[]=explosion_counter_temp, texplosion_updater[]=explosion_updater, timmortality_timer[]=immortality_timer;\u8232 \u8232 //initializing the arrays again to store an extra particle dropped by the bomber\u8232 \u8232 p=new Particle[original_length+1];\u8232 particle_dead=new boolean[p.length];\u8232 explosion_counter=new int[p.length];\u8232 explosion_counter_temp=new int[p.length];\u8232 explosion_updater=new int[p.length];\u8232 is_splitable=new boolean[p.length];\u8232 immortality_timer=new int[p.length];\u8232 is_killable=new boolean[p.length];\u8232 explosion_flag=new boolean[p.length];\u8232 for(int i=0;i<original_length;i++)\{\u8232 is_killable[i]=tis_killable[i];\u8232 immortality_timer[i]=timmortality_timer[i];\u8232 particle_dead[i]=tparticle_dead[i];\u8232 explosion_counter[i]=texplosion_counter[i];\u8232 explosion_counter_temp[i]=texplosion_counter_temp[i];\u8232 explosion_updater[i]=texplosion_updater[i];\u8232 explosion_flag[i]=texplosion_flag[i];\u8232 p[i]=temp[i];\u8232 is_splitable[i]=tis_splitable[i];\u8232 \}\u8232 \u8232 //adding the extra particle and its flags at the end of each array\u8232 \u8232 explosion_counter[p.length-1]=1;\u8232 explosion_counter_temp[p.length-1]=1;\u8232 explosion_updater[p.length-1]=1;\u8232 particle_dead[p.length-1]=false;\u8232 is_splitable[p.length-1]=false;\u8232 immortality_timer[p.length-1]=0;\u8232 p[p.length-1]=bomber.bomb;\u8232 is_killable[p.length-1]=true;\u8232 \}\u8232 \}\
\uc0\u8232 //initializing and drawing the satellite object and initializing its flag\u8232 void add_satellite()\{\u8232 satellite=new Added_enemy((float)random(width+100,width+250+(200*wave)),(float)height/4,30, (float)random(width/2,width));\u8232 satellite.draw_enemy();\u8232 satellite_is_alive=satellite.is_alive;\u8232 \}\
//basically doing the same as the bomber handling function with different values to move the satellite at a different speed\
void handle_satellite()\{\uc0\u8232 satellite.move(wave,0.5);\u8232 satellite.draw_enemy();\u8232 float velx;\u8232 float vely;\u8232 int target=(int)random(0,5);\u8232 switch(target)\{\u8232 case 0:velx=(2*distance+distance/192f);break;\u8232 case 1:velx=(3.1*distance+distance/192f);break;\u8232 case 2:velx=(4.2*distance+distance/192f);break;\u8232 case 3:velx=(6.3*distance+distance/192f);break;\u8232 case 4:velx=(7.4*distance+distance/192f);break;\u8232 case 5:velx=(8.5*distance+distance/192f);break; \u8232 default: velx=0;\u8232 \}\u8232 velx=(velx+((distance/4f)-(distance/96f)-satellite.enemy.x))/(280+(abs(satellite.enemy.y)/30));\u8232 vely=2+(float)wave/32;\u8232 if(satellite.drop_bomb(velx,vely))\{\u8232 int original_length=p.length;\u8232 Particle temp[]=p;\u8232 boolean tparticle_dead[]=particle_dead, tis_splitable[]=is_splitable, tis_killable[]=is_killable,texplosion_flag[]=explosion_flag;\u8232 int texplosion_counter[]=explosion_counter, texplosion_counter_temp[]=explosion_counter_temp, texplosion_updater[]=explosion_updater, timmortality_timer[]=immortality_timer;\u8232 p=new Particle[original_length+1];\u8232 particle_dead=new boolean[p.length];\u8232 explosion_counter=new int[p.length];\u8232 explosion_counter_temp=new int[p.length];\u8232 explosion_updater=new int[p.length];\u8232 is_splitable=new boolean[p.length];\u8232 immortality_timer=new int[p.length];\u8232 is_killable=new boolean[p.length];\u8232 explosion_flag=new boolean[p.length];\u8232 for(int i=0;i<original_length;i++)\{\u8232 is_killable[i]=tis_killable[i];\u8232 immortality_timer[i]=timmortality_timer[i];\u8232 particle_dead[i]=tparticle_dead[i];\u8232 explosion_counter[i]=texplosion_counter[i];\u8232 explosion_counter_temp[i]=texplosion_counter_temp[i];\u8232 explosion_updater[i]=texplosion_updater[i];\u8232 explosion_flag[i]=texplosion_flag[i];\u8232 p[i]=temp[i];\u8232 is_splitable[i]=tis_splitable[i];\u8232 \}\u8232 explosion_counter[p.length-1]=1;\u8232 explosion_counter_temp[p.length-1]=1;\u8232 explosion_updater[p.length-1]=1;\u8232 particle_dead[p.length-1]=false;\u8232 is_splitable[p.length-1]=false;\u8232 immortality_timer[p.length-1]=0;\u8232 p[p.length-1]=satellite.bomb;\u8232 is_killable[p.length-1]=true;\u8232 \} \u8232 \}\
//drawing the crosshair to replace the cursor\
void crosshair()\{\uc0\u8232 stroke(0);\u8232 line(mouseX-6,mouseY-6,mouseX-2,mouseY-2);\u8232 line(mouseX+6,mouseY+6,mouseX+2,mouseY+2);\u8232 line(mouseX+6,mouseY-6,mouseX+2,mouseY-2);\u8232 line(mouseX-6,mouseY+6,mouseX-2,mouseY+2);\u8232 noStroke();\u8232 fill(255,0,0);\u8232 circle(mouseX,mouseY,1);\u8232 \}\
//checking the wave condition and handling what happens when the wave is passed or failed\uc0\u8232 void check_wave()\{\u8232 \u8232 //if the wave was passed\u8232 if(check_wave_condition()==1)\{\u8232 for(int i=0;i<city_dead.length;i++)\u8232 if(city_dead[i]==false)\u8232 score+=(100*(wave>10 ? 6 :((wave+1)/2)));\u8232 score+=((30-active_missile_counter)*5*(wave>10?6:((wave+1)/2)));\u8232 if(score>=10000)\{\u8232 for(int i=0;i<city_dead.length;i++)\u8232 if(city_dead[i] && score >=10000)\{\u8232 city_dead[i]=false;\u8232 score-=10000;\u8232 score_reduction+=10000;\u8232 \}\u8232 \}\u8232 enemy_counter=0;\u8232 add_particles();\u8232 if(wave>5)\{\u8232 smart_bomb_activated=false;\u8232 smart_bomb=(int)random(0,p.length);\u8232 \}\u8232 add_silos();\u8232 active_missile_counter=0;\u8232 for(int i=0;i<detonation_counter.length;i++)\u8232 detonation_counter[i]=detonation_counter_temp[i]=detonation_updater[i]=1;\u8232 for(int i=0;i<missiles.length;i++)\u8232 missiles[i]=null;\u8232 \}\u8232 \u8232 //if the wave failed\u8232 if(check_wave_condition()==2)\{\u8232 fill(30,64,99);\u8232 textAlign(CENTER);\u8232 textSize(23);\u8232 text("You Lose!",width/2,(height/2)-45);\u8232 text("Wave:"+wave,width/2,height/2-20);\u8232 text("Score:"+(score + score_reduction),width/2,height/2+5);\u8232 textSize(12);\u8232 text("Press Spacebar to Try Again.",width/2, (height/2)+30);\u8232 if(keyPressed==true && key==' ')\{\u8232 reset=true;\u8232 start();\u8232 \}\u8232 \}\u8232 \}\
//handling everything that happens to the missile after its shot\uc0\u8232 void shoot_missile()\{\u8232 int i=0; //counter to traverse the array containing all active missiles\u8232 \u8232 while(missiles[i]!=null)\{\u8232 \u8232 //just to confirm we havent crossed the limit of missiles alllowed per wave\u8232 if(active_missile_counter!=31)\{ \u8232 PVector position=missiles[i].position;\u8232 //moving the missile and applying gravity on it\u8232 missiles[i].integrate(g);\u8232 \u8232 //check to see if the smart bomber needs to created by checking the wave value\u8232 if(wave>5)\{\u8232 \u8232 if(particle_dead[smart_bomb]==false)\{\u8232 \u8232 //temporary variable to store the initial particle velocity\u8232 float tvelx=p[smart_bomb].velocity.x, tvely=p[smart_bomb].velocity.y;\u8232 \u8232 //checking if the missile is near its target\u8232 if(missiles[i].desty - missiles[i].position.y <= 50 && abs(missiles[i].destx - missiles[i].position.x) <= 50 && (missiles[i].detonate()!=true || (missiles[i].detonate()==true && detonation_counter[i]>0)) || smart_bomb_activated==true)\{\u8232 \u8232 ///checking if the smart bomb is less than 50 pixels away from the incoming missile\u8232 if(missiles[i].position.y - p[smart_bomb].position.y <= 50 \u8232 && smart_bomb_activated==false \u8232 && ((tvelx>0 && missiles[i].position.x - p[smart_bomb].position.x <= 50)||(tvelx<0 && p[smart_bomb].position.x - missiles[i].position.x <= 50)))\{\u8232 \u8232 //storing the initial velocity of the particle to be reset after a set timer\u8232 smart_bomber_originalvelx=tvelx;\u8232 smart_bomber_originalvely=tvely;\u8232 \u8232 //double the velocity if its too close to the incoming explosion\u8232 p[smart_bomb].velocity=new PVector(tvelx*2,tvely*2);\u8232 p[smart_bomb].invMass=1;\u8232 \u8232 //to stop the smart bomb to be activated multiple times\u8232 smart_bomb_activated=true;\u8232 smart_timer=160;\u8232 \}\u8232 \u8232 //checking if the smart bomb is approaching the incomng missile and is not too close to expected explosion(150 pixels)\u8232 else if(missiles[i].position.y - p[smart_bomb].position.y <= 150 \u8232 && missiles[i].position.y - p[smart_bomb].position.y >= 50 \u8232 && smart_bomb_activated==false \u8232 && ((tvelx>0 && missiles[i].position.x - p[smart_bomb].position.x <= 50)\u8232 ||(tvelx<0 && p[smart_bomb].position.x - missiles[i].position.x <= 50)))\{\u8232 smart_bomber_originalvelx=tvelx;\u8232 smart_bomber_originalvely=tvely;\u8232 \u8232 //slows it down till the explosion is over\u8232 p[smart_bomb].velocity=new PVector(tvelx/8 ,tvely/8 );\u8232 \u8232 //reduce the effect of gravity on the particle by altering its mass\u8232 p[smart_bomb].invMass=4 ;\u8232 \u8232 smart_bomb_activated=true;\u8232 \u8232 //setting a timer for the slowing down effect\u8232 smart_timer=160;\u8232 \}\u8232 \u8232 //checking to see if the particle has passsed the explosion site\u8232 else if(smart_timer <= 1 && smart_bomb_activated==true && missiles[i].position.y - p[smart_bomb].position.y < 0 \u8232 || ((tvelx > 0 && missiles[i].position.x - p[smart_bomb].position.x < -50)\u8232 ||(tvelx < 0 && p[smart_bomb].position.x - missiles[i].position.x < - 50)) )\{\u8232 \u8232 //checking if the timer is off\u8232 if(smart_timer<=1)\{\u8232 \u8232 //reseting the particle\u8232 p[smart_bomb].velocity=new PVector(smart_bomber_originalvelx , smart_bomber_originalvely);\u8232 p[smart_bomb].invMass=1;\u8232 smart_bomb_activated=false;\u8232 \}\u8232 \}\u8232 else\{\u8232 \u8232 //just to keep tract of its velocity and overwrite any false updations\u8232 p[smart_bomb].velocity=new PVector(tvelx,tvely);\u8232 if(frame==true)\{\u8232 smart_timer--;\u8232 frame=false; \u8232 \}\u8232 \}\u8232 \u8232 \} \u8232 \}\u8232 \}\u8232 \u8232 //if the missile reaches its destination, detonate it and make an explosion circle\u8232 if(missiles[i].detonate())\{\u8232 noStroke();\u8232 fill(255,243,166);\u8232 circle(missiles[i].destx,missiles[i].desty,detonation_counter[i]);\u8232 \u8232 //setting the radius of the circle\u8232 if(detonation_counter_temp[i]<40 && detonation_counter[i]>0)\u8232 detonation_counter[i]+=detonation_updater[i];\u8232 \u8232 //setting a timer for the explosion\u8232 detonation_counter_temp[i]+=detonation_updater[i];\u8232 \u8232 //changing the updater for the explosion radius and timer to start reducing the respective value to save a step and variable in updation\u8232 if(abs(detonation_counter_temp[i])==80)\u8232 detonation_updater[i]*=(-1);\u8232 \u8232 //checking collision with satellite or bomber wave 2 onwards\u8232 if(wave>1)\{\u8232 boolean tempa = bomber_is_alive, tempb = satellite_is_alive;\u8232 bomber_is_alive=bomber.check_collision(missiles[i].destx,missiles[i].desty,detonation_counter[i]);\u8232 satellite_is_alive=satellite.check_collision(missiles[i].destx,missiles[i].desty,detonation_counter[i]);\u8232 if(bomber_is_alive==false && tempa==true &&bomber.is_shot==true)\u8232 score+= (100*(wave>10?6:((wave+1)/2)));\u8232 if(satellite_is_alive==false && tempb==true && satellite.is_shot==true)\u8232 score+= (100*(wave>10?6:((wave+1)/2)));\u8232 \}\u8232 \u8232 //checking collision with each particle\u8232 for(int j=0;j<p.length;j++)\{\u8232 boolean ptemp=particle_dead[j];\u8232 if(is_killable[j])\u8232 particle_dead[j]=p[j].particle_dead(missiles[i].destx,missiles[i].desty,detonation_counter[i]);\u8232 else if(immortality_timer[j]==0)\{is_killable[j]=true;\}\u8232 else if(immortality_timer[j]>0) \{immortality_timer[j]--;\}\u8232 if(particle_dead[j]==true && ptemp!=true) \u8232 score+= (25*(wave>10?6:((wave+1)/2)));\u8232 if(((particle_dead[j]==true && ptemp!=true) || explosion_counter[j]!=1)&& explosion_flag[j]==false)\{\u8232 explosion_flag[j]=true;\u8232 explode_particle(j);\u8232 \u8232 //checking if the particle can be split\u8232 if(is_splitable[j])\{\u8232 is_splitable[j]=false;\u8232 split(p[j],0);\u8232 \}\u8232 \}\u8232 \u8232 \}\u8232 \}\u8232 else\{\u8232 fill(255,10,100);\u8232 rect(position.x,position.y,3,2);\u8232 \}\u8232 i++;\u8232 \}\u8232 else\u8232 return;\u8232 \}\u8232 \}\
//if a particle collides with the missile explosion, explode the particle in a similar way\uc0\u8232 void explode_particle(int index)\{\u8232 noStroke();\u8232 fill(255,243,166);\u8232 circle(p[index].position.x,p[index].position.y,explosion_counter[index]);\u8232 if(explosion_counter_temp[index]<40 && explosion_counter[index]>0)\u8232 explosion_counter[index]+=explosion_updater[index];\u8232 explosion_counter_temp[index]+=explosion_updater[index];\u8232 if(abs(explosion_counter_temp[index])==80)\u8232 explosion_updater[index]*=(-1);\u8232 if(wave>1)\{\u8232 boolean tempa = bomber_is_alive, tempb = satellite_is_alive;\u8232 bomber_is_alive=bomber.check_collision(p[index].position.x,p[index].position.y,explosion_counter[index]);\u8232 satellite_is_alive=satellite.check_collision(p[index].position.x,p[index].position.y,explosion_counter[index]);\u8232 if(bomber_is_alive==false && tempa==true)\u8232 score+= (100*(wave>10?6:((wave+1)/2)));\u8232 if(satellite_is_alive==false && tempb==true)\u8232 score+= (100*(wave>10?6:((wave+1)/2)));\u8232 \}\u8232 for(int i=0;i<p.length;i++)\{\u8232 boolean ptemp=particle_dead[i];\u8232 if(is_killable[i])\u8232 particle_dead[i]=p[i].particle_dead(p[index].position.x,p[index].position.y,explosion_counter[index]);\u8232 else if(immortality_timer[i]==0)\{is_killable[i]=true;\}\u8232 else if(immortality_timer[i]>0) \{immortality_timer[i]--;\}\u8232 if((particle_dead[i]==true && ptemp!=true))\{\u8232 score+= (25*(wave>10?6:((wave+1)/2)));\u8232 \u8232 //calling itself to check if the explosion caused by the particle is exploding more particles\u8232 explode_particle(i);\u8232 if(is_splitable[i])\{\u8232 is_splitable[i]=false;\u8232 split(p[i],1);\u8232 \}\u8232 \}\u8232 \}\u8232 \}\
//function to handle splitting particles wave 2 onwards\uc0\u8232 void split(Particle parent,int check)\{\u8232 \u8232 //randomly assigning the number of children each particle will have\u8232 int no_of_children=(int)random(2,5);\u8232 int original_length=p.length;\u8232 \u8232 //adding particles to the existing arrays by creating temporary arrays to store the initial values and then reinitializing the existing arrays with a new length to include more particles\u8232 Particle temp[]=p;\u8232 boolean tparticle_dead[]=particle_dead, tis_splitable[]=is_splitable, tis_killable[]=is_killable,texplosion_flag[]=explosion_flag;\u8232 int texplosion_counter[]=explosion_counter, texplosion_counter_temp[]=explosion_counter_temp, texplosion_updater[]=explosion_updater, timmortality_timer[]=immortality_timer;\u8232 p=new Particle[original_length+no_of_children];\u8232 particle_dead=new boolean[p.length];\u8232 explosion_counter=new int[p.length];\u8232 explosion_counter_temp=new int[p.length];\u8232 explosion_updater=new int[p.length];\u8232 is_splitable=new boolean[p.length];\u8232 immortality_timer=new int[p.length];\u8232 is_killable=new boolean[p.length];\u8232 explosion_flag=new boolean[p.length];\u8232 for(int i=0;i<original_length;i++)\{\u8232 is_killable[i]=tis_killable[i];\u8232 immortality_timer[i]=timmortality_timer[i];\u8232 particle_dead[i]=tparticle_dead[i];\u8232 explosion_counter[i]=texplosion_counter[i];\u8232 explosion_counter_temp[i]=texplosion_counter_temp[i];\u8232 explosion_updater[i]=texplosion_updater[i];\u8232 explosion_flag[i]=texplosion_flag[i];\u8232 p[i]=temp[i];\u8232 is_splitable[i]=tis_splitable[i];\u8232 \}\u8232 for(int i=original_length;i<p.length;i++)\{\u8232 explosion_counter[i]=1;\u8232 explosion_counter_temp[i]=1;\u8232 explosion_updater[i]=1;\u8232 particle_dead[i]=false;\u8232 is_splitable[i]=false;\u8232 int target=(int)random(0,6);\u8232 switch(target)\{\u8232 case 0:velx=(2*distance+distance/192f);break;\u8232 case 1:velx=(3.1*distance+distance/192f);break;\u8232 case 2:velx=(4.2*distance+distance/192f);break;\u8232 case 3:velx=(6.3*distance+distance/192f);break;\u8232 case 4:velx=(7.4*distance+distance/192f);break;\u8232 case 5:velx=(8.5*distance+distance/192f);break;\u8232 \}\u8232 fill(0);\u8232 velx=(velx+((distance/4f)-(distance/96f)-parent.position.x))/(280+(abs(parent.position.y)/30));\u8232 p[i]=new Particle(parent.position.x,parent.position.y,velx,2+(float)wave/32,1);\u8232 if(check==0)\u8232 immortality_timer[i]=160;\u8232 else\u8232 immortality_timer[i]=320;\u8232 is_killable[i]=false;\u8232 \}\u8232 \}\
//to set the flag for dead particles so they wont be used in any other function and wont be drawn\uc0\u8232 void remove_particles()\{\u8232 for(int i=0;i<p.length;i++)\u8232 particle_dead[i]=p[i].particle_dead();\u8232 \}\
//to add particles to the particlee array and to initialize all the arrays supporting the main particle arrays with default values\uc0\u8232 void add_particles()\{\u8232 p= new Particle[15+(wave++*5)];\u8232 is_killable=new boolean[p.length]; //to store if a particle is killable or not (helps while splitting particles to give them time to escape the explosion they were born from)\u8232 immortality_timer=new int[p.length]; //to keep track of the time left before the split particles are killable\u8232 is_splitable=new boolean[p.length]; //to keep track of all the splitable particles\u8232 explosion_flag=new boolean[p.length]; // flag to make sure explosion starts once foor each particle\u8232 for(int i=0;i<p.length;i++)\u8232 is_splitable[i]=false;\u8232 if(wave>=2)\{\u8232 splitting_particles=wave*2;\u8232 for(int i=0;i<splitting_particles;i++)\{\u8232 int split_random=(int)random(0,p.length);\u8232 if(is_splitable[split_random]==true)\u8232 i--;\u8232 else\u8232 is_splitable[split_random]=true;\u8232 \}\u8232 \}\u8232 particle_dead=new boolean[p.length];\u8232 explosion_counter=new int[p.length];\u8232 explosion_counter_temp=new int[p.length];\u8232 explosion_updater=new int[p.length];\u8232 for(int i=0;i<p.length;i++)\{\u8232 is_killable[i]=true;\u8232 immortality_timer[i]=0;\u8232 explosion_counter[i]=1;\u8232 explosion_counter_temp[i]=1;\u8232 explosion_updater[i]=1;\u8232 explosion_flag[i]=false;\u8232 particle_dead[i]=false;\u8232 \u8232 //randomly assigning a starting position to the particle above the visible screen area\u8232 int location= (int)random(0,width);\u8232 int start_height=(int)random(-(p.length*100),0);\u8232 \u8232 //calculating the target based on the starting position of each particle\u8232 \u8232 int target=6*location/800;\u8232 \u8232 //assigning initial velocity to reach the set target\u8232 switch(target)\{\u8232 case 0:velx=(2*distance+distance/192f);break;\u8232 case 1:velx=(3.1*distance+distance/192f);break;\u8232 case 2:velx=(4.2*distance+distance/192f);break;\u8232 case 3:velx=(6.3*distance+distance/192f);break;\u8232 case 4:velx=(7.4*distance+distance/192f);break;\u8232 case 5:velx=(8.5*distance+distance/192f);break;\u8232 \}\u8232 fill(0);\u8232 velx=(velx+((distance/4f)-(distance/96f)-location))/(280+(abs(start_height)/30));\u8232 p[i]=new Particle(location,start_height,velx,2+(float)wave/32,1);\u8232 \}\u8232 \}\
//function to initialize and create the city object array\uc0\u8232 void add_cities(float particleX,float particleY)\{\u8232 float dimensions[]= new float[4];\u8232 for(int i=0;i<cities.length;i++)\{\u8232 switch(i)\{\u8232 case 0:\{\u8232 fill(0);\u8232 dimensions[0]=2*distance+(distance/192f);\u8232 dimensions[1]=altitude-5;\u8232 dimensions[2]=(distance/2f)-(distance/96f);\u8232 dimensions[3]= altitude/80f;\u8232 \}break;\u8232 case 1:\{\u8232 fill(0);\u8232 dimensions[0]=(3.1*distance)+(distance/192f);\u8232 dimensions[1]=altitude-5;\u8232 dimensions[2]=(distance/2f)-(distance/96f);\u8232 dimensions[3]=altitude/80f;\u8232 \}break;\u8232 case 2:\{\u8232 fill(0);\u8232 dimensions[0]=(4.2*distance)+(distance/192f);\u8232 dimensions[1]=altitude-5;\u8232 dimensions[2]=(distance/2f)-(distance/96f);\u8232 dimensions[3]=altitude/80f;\u8232 \}break;\u8232 case 3:\{\u8232 fill(0);\u8232 dimensions[0]=(6.3*distance)+(distance/192f);\u8232 dimensions[1]=altitude-5;\u8232 dimensions[2]=(distance/2f)-(distance/96f);\u8232 dimensions[3]=altitude/80f;\u8232 \}break;\u8232 case 4:\{\u8232 fill(0);\u8232 dimensions[0]=(7.4*distance)+(distance/192f);\u8232 dimensions[1]=altitude-13;\u8232 dimensions[2]=(distance/2f)-(distance/96f);\u8232 dimensions[3]=altitude/40f;\u8232 \}break;\u8232 case 5:\{\u8232 fill(0);\u8232 dimensions[0]=(8.5*distance)+(distance/192f);\u8232 dimensions[1]=altitude-5;\u8232 dimensions[2]=(distance/2f)-(distance/96f);\u8232 dimensions[3]=altitude/80f;\u8232 \}break;\u8232 \}\u8232 cities[i]=new City(dimensions[0],dimensions[1],(dimensions[0]+dimensions[2]),(dimensions[1]+dimensions[3]));\u8232 if(cities[i].isAlive(particleX,particleY)&&city_dead[i]==false)\{\u8232 noStroke();\u8232 fill(133,133,133);\u8232 \}\u8232 else\{\u8232 noStroke();\u8232 fill(123,0,0);\u8232 city_dead[i]=true;\u8232 \}\u8232 rect(dimensions[0],dimensions[1],dimensions[2],dimensions[3]);\u8232 \}\u8232 \}\
//checking to see if therre are any particles or cities left to decide if the wave has been won(1) or lost(2) or still going on(0)\uc0\u8232 int check_wave_condition()\{\u8232 for(int j=0;j<city_dead.length;j++)\u8232 if(city_dead[j]==false)\{\u8232 for(int i=0;i<particle_dead.length;i++)\u8232 if(particle_dead[i]==false || bomber_is_alive==true || satellite_is_alive==true)\u8232 return 0;\u8232 return 1;\}\u8232 return 2;\u8232 \u8232 \}\
//add the silos each round and reset the missile counter sso that each silo has 10 missile\uc0\u8232 void add_silos()\{\u8232 dead_missiles=0;\u8232 float dimensions[]= new float[4];\u8232 for(int i=0;i<s.length;i++)\{\u8232 silo_dead[i]=false;\u8232 switch(i)\{\u8232 case 0: \{\u8232 dimensions[0]=0.5*distance+(distance/192f);\u8232 dimensions[1]=altitude-25;\u8232 dimensions[2]=(distance)-(distance/96f);\u8232 dimensions[3]= altitude/20f;\u8232 \}break;\u8232 case 1: \{\u8232 dimensions[0]=5*distance+(distance/192f);\u8232 dimensions[1]=altitude-25;\u8232 dimensions[2]=(distance)-(distance/96f);\u8232 dimensions[3]= altitude/20f;\u8232 \}break;\u8232 case 2: \{\u8232 dimensions[0]=9.4*distance+(distance/192f);\u8232 dimensions[1]=altitude-25;\u8232 dimensions[2]=(distance)-(distance/96f);\u8232 dimensions[3]= altitude/20f;\u8232 \}break;\u8232 \}\u8232 s[i]=new Silo(dimensions[0],dimensions[1],dimensions[0]+dimensions[2],dimensions[1]+dimensions[3]);\u8232 \}\u8232 \}\
//drawing the silos each frame with the updated missile counter aand their state(alive or dead)\uc0\u8232 void draw_silos(float px,float py)\{\u8232 for(int i=0;i<s.length;i++)\{\u8232 if(s[i].isAlive(px,py) && silo_dead[i]==false)\{\u8232 noStroke();\u8232 fill(58,74,44);\u8232 rect(s[i].x1,s[i].y1,s[i].x2-s[i].x1,s[i].y2-s[i].y1);\u8232 \}\u8232 else\{\u8232 noStroke();\u8232 fill(94,44,29);\u8232 rect(s[i].x1,s[i].y1,s[i].x2-s[i].x1,s[i].y2-s[i].y1);\u8232 silo_dead[i]=true;\u8232 if(s[i].missile_counter!=0)\u8232 dead_missiles=s[i].missile_counter;\u8232 s[i].missile_counter=0;\u8232 \}\u8232 textAlign(CENTER);\u8232 fill(255);\u8232 text(s[i].missile_counter,((s[i].x1+s[i].x2)/2),(s[i].y1+s[i].y2)/2);\u8232 \}\u8232 \}\
//handling the mouse click event to store the coordinates of the click to launch a missile to the destination from the nearest silo with usaable missiles\uc0\u8232 void mouseClicked()\{\u8232 if(active_missile_counter+dead_missiles<30 && check_wave_condition()!=2 && start==true && s[0].missile_counter+s[1].missile_counter+s[2].missile_counter >0 )\{\u8232 float mtargetx=mouseX;\u8232 float mtargety=(600-mouseY);\u8232 int origin=3*(int)(mtargetx-2)/800;\u8232 shoot(origin, mtargetx, mtargety);\u8232 \}\u8232 \}\
//handling key press events to give the user control over while silo they want the missile to be launched from\uc0\u8232 void keyPressed()\{\u8232 if((keyCode == UP ||keyCode == RIGHT ||keyCode == LEFT) && start==true )\{\u8232 if(active_missile_counter+dead_missiles<30 && check_wave_condition()!=2)\{\u8232 float mtargetx=mouseX;\u8232 float mtargety=(600-mouseY);\u8232 int origin;\u8232 if(keyCode == UP) origin = 1;\u8232 else if(keyCode == RIGHT) origin = 2;\u8232 else origin = 0;\u8232 shoot(origin, mtargetx, mtargety);\u8232 \}\u8232 \}\u8232 \}\
//the function actually creating the missile object and giving it initial velocity (which is slightly higher if shot from the center missile silo)\uc0\u8232 void shoot(int origin, float mtargetx, float mtargety)\{\u8232 if(s[origin].missile_counter==0)\{\u8232 switch(origin)\{\u8232 case 0:\{if(s[1].missile_counter!=0) origin=1; else if(s[2].missile_counter!=0) origin=2; \}break;\u8232 case 1:\{ origin= (int)mtargetx/400; if(origin==1) origin=2; if(s[0].missile_counter==0) origin=2; else if(s[2].missile_counter==0) origin=0;\}break;\u8232 case 2:\{if(s[1].missile_counter!=0) origin=1; else if(s[0].missile_counter!=0) origin=0; \}break;\u8232 \}\u8232 \}\u8232 if(origin==1)\u8232 s[origin].shoot_missile((s[origin].x1+s[origin].x2)/2,s[origin].y1,(mtargetx-((s[origin].x1+s[origin].x2)/2))/23,-mtargety/23,1,mouseX,mouseY);\u8232 else\u8232 s[origin].shoot_missile((s[origin].x1+s[origin].x2)/2,s[origin].y1,(mtargetx-((s[origin].x1+s[origin].x2)/2))/28,-mtargety/29,1,mouseX,mouseY);\u8232 missiles[active_missile_counter++]=s[origin].missile;\
\}\
\
Particle\
//particle class tweaked from the particle class used in the tutorial sketch for drag\
class Particle\{\uc0\u8232 \u8232 public PVector velocity, position, acceleration;\u8232 public static final float drag=0.99995f;\u8232 boolean dead;\u8232 float destx,desty;\u8232 float invMass;\u8232 Particle(float x, float y, float vel1, float vel2, float m)\{\u8232 velocity = new PVector(vel1, vel2);\u8232 position = new PVector(x, y);\u8232 acceleration= new PVector();\u8232 invMass=m;\u8232 dead=false;\u8232 \}\u8232 \u8232 //overloading the constructor for missiles\u8232 Particle(float x, float y, float vel1, float vel2, float m, float dx, float dy)\{\u8232 velocity = new PVector(vel1, vel2);\u8232 position = new PVector(x, y);\u8232 acceleration= new PVector();\u8232 invMass=m;\u8232 destx=dx;\u8232 desty=dy;\u8232 \}\u8232 \u8232 //using the same way to calculate motion and gravity but different collisions as per the world\u8232 void integrate(PVector force) \{\u8232 if (invMass <= 0f) return ;\u8232 \u8232 position.add(velocity) ;\u8232 \u8232 acceleration.add(force) ;\u8232 acceleration.mult(1/invMass) ;\u8232 if(velocity.mag()<2)\u8232 velocity.add(acceleration) ;\u8232 velocity.mult(drag);\u8232 if ((position.x < 0) || (position.x > width)) velocity.x = -velocity.x*0.9 ;\u8232 if (position.y > height-5) \{velocity.y = 0 ; velocity.x = 0;\}\u8232 \}\u8232 \u8232 //to store the particle state\u8232 boolean particle_dead()\{\u8232 if (position.y > height-5) \u8232 dead= true;\u8232 return dead;\u8232 \}\u8232 \u8232 //overloading the function for missiles\u8232 boolean particle_dead(float cx, float cy, int r)\{\u8232 PVector circle=new PVector(cx,cy);\u8232 if(circle.dist(position)<=r/2)\u8232 dead=true;\u8232 return dead;\u8232 \}\u8232 \u8232 //checking to see if the missile reached its destination\u8232 boolean missile_hit(float mouse_x, float mouse_y)\{\u8232 if(position.x==mouse_x&&position.y==mouse_y)\u8232 return true;\u8232 return false;\u8232 \}\u8232 \u8232 //checking if its time to detonate\u8232 boolean detonate()\{\u8232 if((int)position.y<=(int)desty)\u8232 return true;\u8232 return false;\u8232 \}\u8232 \}\
\
Silo\
\
//class silo that uses the basic instances and methods of the city class but adds arguments and a method for missiles\
\
class Silo extends City\{\
///creates the missiles and keeps track of the missiles left\
Particle missile;\
int missile_counter;\
Silo(float x1, float y1, float x2, float y2)\{\
super(x1, y1, x2, y2);\
missile_counter=10;\
\}\
\
//creating a new object for missile each time this function is called\
void shoot_missile(float x, float y, float velx, float vely, float m, float dx, float dy)\{\
if(missile_counter>0)\{\
missile=new Particle(x,y,velx,vely,m,dx,dy);\
missile_counter--;\
\}\
else\
return;\
\}\
\}\
}